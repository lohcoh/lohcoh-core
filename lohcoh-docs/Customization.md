# Customization

lowkode has support for two common requirements for customization...
- The ability to customize the visual aspects of the UI via CSS.  For instance, set the application navbar background to black.
- The ability to customize UI components and model data.  For instance, add an extra link to the application navbar for a particular customer.
lowkode doesn't concern itself with visual styling.  
To support visual styling, a lowkode Component's associated DOM element can be decorated with custom classes.  
Rules are used to add these custom classes to components.

## Overview of how lowkode works
Lowkode generates a UI from Metadata, Components, Rules, and Context
- Metadata: Data that describes the system that the UI fronts.  
	This includes schemas for objects, available services, UI contributions, etc.
- Rules:  Rules modify a Context given some, optional, data.
	Examples of what can be done with Rules...
	- globally replace the component used to display dates
	- use a custom Card component when displaying an Album in a Card and the Album won a Grammy.
	- Add an additional Report to the Report menu for a specific customer
	- When displaying an Employee in a Form, make the SSN field optional when the client is not located in the US.
- Components: UI elements that display objects.
	Every Component has it's own Context, and the exact UI generated by a component is influenced by Metadata, Rules, and Context.
- Context:  Runtime data and service provider injected into every Component that provides access to Metadata and other Components.
	A Context is a kind of service provider.  A new Context can be created from an existing Context, the Metadata and Components provided by the 
	new Context may be different from that provided by the parent Context, depending on the data used to construct the new Context.
	Components may not modify Contexts, Contexts may only be modified by Rules.
	Rules are only executed when a new Context is created.

Lowkode is 'customized' by adding Rules to the lowkode Rule service.
Rules have triggers and actions.  
Rules can be triggered by matching values to elements in a given Context.
Actions modify the context to create a new context.


## Multidimensional selectors
Here's an incomplete? list of parameters used to select a UI part...
- The domain element associated with the element, if any
	Attributes on the associated domain element can determine how the element is displayed.
	For instance, a property can be marked as required.
- The tag associated with the element
	The tag specifics how the associated view model should be displayed.
	That is, a <Form> tag will display a domain object differently than a <Card> element.
- The model object.
	Attributes on the model object can determine how the element is displayed.
	For instance, suppose you want to customise the Title background color on <Card> elements that 
	display Employees based on the Department to which the Employee belongs.
- The current context
	For example, hide a UI element if the current user does not a permission to access.

Any specific Component can be categorized in any one of many ways...
- As a part of the application model, for example, as an Employee's first name.
- As a part of UI widget, for example, as a text box that displays the Employee's first name.
- As a piece of data, for example, as a string.

## Properties

### Field/Property Titles
Json Schema Property: title
C# : System.ComponentModel.DataAnnotations.DisplayAttribute
Add an 'x-lowkode-annotations' object to properties that will propagate data from the System.ComponentModel.DataAnnotations attributes
	

