using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.RenderTree;
using System;

namespace LowKode.Core.Components
{
#pragma warning disable BL0006 // Do not use RenderTree types
    /// <summary>
    /// Changes the contents generated by a given RenderFragment by replacing every component with an instance 
    /// of LowkoderComponentDecorator.
    /// In this way, Lowkoder injects itself into the entire Blazor component tree, where Lowkoder can work its 
    /// magic.
    /// </summary>
    internal class RenderFragmentTranslator
    {
        public static RenderFragment Translate(RenderFragment childContent)
        {
            // It would be more efficient to create a subclass of RenderTreeBuilder that would 
            // translate calls from the given RenderFragment to a RenderTreeBuilder on the fly.
            // But RenderTreeBuilder is sealed, so what we do is have the fragment render it's content 
            // and then get the frames that represent the content from the builder.
            // Then we use these frames to replay the the actions of the fragment, only we 
            // replace component types.
            var builder = new RenderTreeBuilder();
            childContent(builder);

            return b => BuildRenderTree(b, builder.GetFrames().Array.AsSpan<RenderTreeFrame>());
        }

        static void BuildRenderTree(RenderTreeBuilder builder, Span<RenderTreeFrame> frames)
        {
            var aFrames = frames.ToArray();
            for (int iFrame = 0; iFrame < aFrames.Length; iFrame++)
            {
                var frame = aFrames[iFrame];
                switch (frame.FrameType)
                {
                    case RenderTreeFrameType.None:
                        break;

                    case RenderTreeFrameType.Element:
                        builder.OpenElement(frame.Sequence, frame.ElementName);

                        BuildRenderTree(builder, aFrames.AsSpan(iFrame + 1, frame.ElementSubtreeLength));
                        iFrame+= frame.ElementSubtreeLength;

                        builder.CloseElement();
                        break;

                    case RenderTreeFrameType.Text:
                        builder.AddContent(frame.Sequence, frame);
                        break;

                    case RenderTreeFrameType.Attribute:
                        builder.AddAttribute(frame.Sequence, frame);
                        break;

                    case RenderTreeFrameType.Component:
                        builder.OpenComponent(frame.Sequence, typeof(LowkoderComponentDecorator));

                        if (frame.ComponentType != null)
                        {
                            builder.AddAttribute(frame.Sequence, nameof(LowkoderComponentDecorator.ComponentType), frame.ComponentType);
                        }
                        if (frame.ComponentReferenceCaptureAction != null)
                        {
                            builder.AddAttribute(frame.Sequence, nameof(LowkoderComponentDecorator.ComponentReferenceCaptureAction), frame.ComponentReferenceCaptureAction);
                        }
                        if (frame.ComponentType != null)
                        {
                            builder.AddAttribute(frame.Sequence, nameof(LowkoderComponentDecorator.ComponentKey), frame.ComponentKey);
                        }

                        BuildRenderTree(builder, aFrames.AsSpan(iFrame + 1, frame.ComponentSubtreeLength));
                        iFrame += frame.ComponentSubtreeLength;

                        builder.CloseComponent();
                        break;

                    case RenderTreeFrameType.Region:
                        builder.OpenRegion(frame.Sequence);

                        BuildRenderTree(builder, aFrames.AsSpan(iFrame + 1, frame.RegionSubtreeLength));
                        iFrame += frame.RegionSubtreeLength;

                        builder.CloseRegion();
                        break;

                    case RenderTreeFrameType.ElementReferenceCapture:
                        throw new Exception("unfinished"); // todo: unfinished
                        //break;
                    case RenderTreeFrameType.ComponentReferenceCapture:
                        throw new Exception("unfinished"); // todo: unfinished
                        //break;

                    case RenderTreeFrameType.Markup:
                        builder.AddMarkupContent(frame.Sequence, frame.MarkupContent);
                        break;
                    default:
                        throw new Exception("Unknown frame type:" + frame.FrameType);

                }
            }
        }
#pragma warning restore BL0006 // Do not use RenderTree types
    }
}